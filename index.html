<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BaseMeme Layer Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Define Custom Colors */
        :root {
            --color-dark-bg: #302c44;
            --color-accent: #547cf4;
            --color-primary-action: #4362e5;
            --color-general-button: #a09bc5;
            --color-dark-accent: #0e1f72;
            --color-section-bg: #6f66a8;
            --color-white: #FFFFFF;
            --color-black: #000000;
            --color-selection-red: #ff3838; /* Used for layer selection/resizing */
        }

        /* --- LOCAL FONT LOADING --- */
        @font-face { font-family: 'AppGlobalFont'; src: url('./fonts/font4.otf') format('opentype'); font-weight: normal; font-style: normal; }
        @font-face { font-family: 'LocalFont1'; src: url('./fonts/font1.ttf') format('truetype'); font-weight: normal; font-style: normal; }
        @font-face { font-family: 'LocalFont2'; src: url('./fonts/font2.ttf') format('truetype'); font-weight: normal; font-style: normal; }
        @font-face { font-family: 'LocalFont3'; src: url('./fonts/font3.ttf') format('truetype'); font-weight: normal; font-style: normal; }

        /* Base styles */
        body {
            font-family: 'AppGlobalFont', sans-serif;
            background-color: var(--color-dark-bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Canvas container setup */
        .canvas-container {
            position: relative; 
            display: inline-block; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: var(--color-white); 
            transition: transform 0.3s ease; /* Smooth scaling */
        }
        #memeCanvas { display: block; touch-action: none; }
        #drawingCanvas { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        #drawingCanvas.active-drawing { pointer-events: auto; cursor: crosshair; }

        /* Canvas Resize Handle (For overall canvas size) */
        #resizeHandle {
            position: absolute;
            bottom: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background-color: var(--color-accent);
            border: 3px solid var(--color-white);
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 20;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: none;
        }
        
        /* Layer Resize Handle (NEW: For scaling layers) */
        #layerResizeHandle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: var(--color-selection-red);
            border: 3px solid var(--color-white);
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 15; /* Higher than drawing, lower than canvas resize */
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            touch-action: none;
            display: none; /* Only show when image layer is selected */
        }
        
        /* General Button Styling */
        .control-button {
            transition: all 0.15s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: var(--color-black);
            background-color: var(--color-general-button);
        }
        .control-button:hover {
            transform: translateY(-1px);
            background-color: #8c90b6;
        }
        .primary-action-button {
            background-color: var(--color-primary-action);
            color: var(--color-white);
        }
        .primary-action-button:hover {
            background-color: var(--color-dark-accent);
        }
        .selected-item {
            border-width: 4px;
            border-color: var(--color-accent) !important;
        }

        /* --- MOBILE LAYOUT (App-like Drawer/Modal System) --- */
        #preview-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1; 
            padding: 1rem;
            position: relative;
        }
        
        /* Floating Action Button */
        #main-controls-fab {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 30;
            background-color: var(--color-accent);
            color: var(--color-white);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
            transition: background-color 0.15s;
        }
        #main-controls-fab:hover {
            background-color: var(--color-primary-action);
        }

        /* Modal/Drawer Container */
        .app-drawer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 40;
            display: none; 
        }
        .app-drawer-content {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%; 
            max-width: 400px; 
            height: 100%;
            background-color: var(--color-dark-bg);
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            transform: translateX(100%); 
            transition: transform 0.3s ease-out;
            padding: 1rem;
            overflow-y: auto;
        }
        .app-drawer-container.active {
             display: block; /* Show container when active */
        }
        .app-drawer-container.active .app-drawer-content {
            transform: translateX(0);
        }
        
        /* Secondary Panel/Modal for selections (Images, Fonts, etc) */
        .secondary-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-dark-bg);
            transform: translateX(100%); 
            transition: transform 0.3s ease-out;
            padding: 1rem;
            overflow-y: auto;
        }
        .secondary-panel.active {
            transform: translateX(0); 
        }

        /* --- DESKTOP LAYOUT (Retaining two-column for large screens) --- */
        @media (min-width: 1024px) {
            body { 
                height: 100vh; 
                overflow: hidden; 
                flex-direction: row; 
            }
            #main-controls-fab {
                display: none; 
            }
            .app-drawer-container {
                position: static;
                width: 33.3333%;
                height: 100%;
                display: block !important; 
                background-color: transparent;
                order: 1;
                z-index: 20;
            }
            .app-drawer-content {
                position: static;
                width: 100%;
                max-width: none;
                height: 100%;
                transform: translateX(0); 
                box-shadow: none;
                padding-bottom: 6rem; 
            }
            .secondary-panel {
                position: absolute;
                height: 100%;
                z-index: 50; 
            }
            #preview-wrapper {
                width: 66.6667%; 
                height: 100vh; 
                order: 2;
                overflow: auto; 
            }
            .sticky-footer {
                position: sticky; 
                bottom: 0; 
                left: 0; 
                width: 100%; 
                background-color: var(--color-dark-bg);
                padding: 1rem 0; 
                border-top: 1px solid var(--color-accent);
            }
        }
    </style>
</head>
<body>

    <div id="preview-wrapper">
        <div id="preview" class="w-full flex items-center justify-center relative">
            <div id="canvas-container" class="canvas-container rounded-xl shadow-2xl">
                <canvas id="memeCanvas" class="touch-none"></canvas>
                <canvas id="drawingCanvas" class="touch-none"></canvas>
                <div id="resizeHandle"></div>
                <div id="layerResizeHandle" style="display: none;"></div>
            </div>
        </div>
    </div>

    <div id="main-controls-fab" onclick="toggleMainDrawer()">
        ‚öôÔ∏è
    </div>

    <div id="app-drawer-container" class="app-drawer-container">
        <div id="app-drawer-content" class="app-drawer-content">
            <div class="flex justify-between items-center border-b border-[--color-accent] pb-3 mb-4 sticky top-0 bg-[--color-dark-bg] z-50 pt-2">
                <h1 class="text-2xl font-extrabold text-[--color-accent]">üõ†Ô∏è Meme Editor</h1>
                <button onclick="toggleMainDrawer()" class="text-white text-2xl p-2 rounded-full hover:bg-[--color-dark-accent]">
                    &times; </button>
            </div>
            
            <p class="text-sm text-gray-200 mb-4" id="baseAppStatus">BaseApp Status: Connecting...</p>
            
            <div id="main-menu" class="space-y-3">
                
                <button onclick="openSecondaryPanel('upload')" class="control-button w-full py-3 font-bold rounded-lg text-lg flex justify-between items-center bg-[--color-general-button] hover:bg-gray-200">
                    <span>üñºÔ∏è Image & Background</span>
                    <span>></span>
                </button>
                
                <button onclick="openSecondaryPanel('templates')" class="control-button w-full py-3 font-bold rounded-lg text-lg flex justify-between items-center bg-[--color-general-button] hover:bg-gray-200">
                    <span>üìë Templates</span>
                    <span>></span>
                </button>
                
                <button onclick="openSecondaryPanel('stickers')" class="control-button w-full py-3 font-bold rounded-lg text-lg flex justify-between items-center bg-[--color-general-button] hover:bg-gray-200">
                    <span>‚ú® Stickers & Items</span>
                    <span>></span>
                </button>
                
                <button onclick="openSecondaryPanel('text')" class="control-button w-full py-3 font-bold rounded-lg text-lg flex justify-between items-center bg-[--color-general-button] hover:bg-gray-200">
                    <span>üÖ∞Ô∏è Text & Fonts</span>
                    <span>></span>
                </button>
                
                <button onclick="openSecondaryPanel('drawing')" class="control-button w-full py-3 font-bold rounded-lg text-lg flex justify-between items-center bg-[--color-general-button] hover:bg-gray-200">
                    <span>‚úèÔ∏è Drawing Tool</span>
                    <span>></span>
                </button>
                
                <hr class="border-[--color-accent] my-4">

                <h2 class="text-xl font-bold text-[--color-accent] pt-2">Selected Layer: <span id="currentLayerTypeDisplay">None</span></h2>
                
                <div id="contextualControls" class="space-y-4">
                     <div id="commonControls" class="hidden space-y-3">
                        <button onclick="deleteSelectedLayer()" class="control-button w-full py-3 rounded bg-red-500 hover:bg-red-600 text-white font-bold">
                            üóëÔ∏è Delete Selected Layer
                        </button>
                    </div>
                    
                    <div id="transformationControls" class="space-y-4 hidden p-3 rounded-lg bg-[--color-section-bg]">
                        <h3 class="text-lg font-semibold text-white">Transformations</h3>
                        <div>
                            <label for="rotationSlider" class="block text-sm font-medium text-white">
                                Rotation: <span id="rotationValue">0¬∞</span>
                            </label>
                            <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0" class="w-full h-2 bg-[--color-accent] rounded-lg appearance-none cursor-pointer range-lg" oninput="updateRotation(event.target.value)">
                        </div>
                        <div class="flex flex-wrap items-center gap-3">
                            <button id="flipXBtn" onclick="toggleFlip('flipX')" class="control-button px-3 py-2 rounded">
                                ‚ÜîÔ∏è Flip X (Mirror)
                            </button>
                            <button id="flipYBtn" onclick="toggleFlip('flipY')" class="control-button px-3 py-2 rounded">
                                ‚ÜïÔ∏è Flip Y
                            </button>
                        </div>
                    </div>
                </div>

            </div>

            <div class="sticky-footer flex flex-col space-y-2 mt-6">
                <button onclick="postToBaseApp()" class="control-button w-full py-3 font-bold rounded-lg shadow-lg bg-green-500 hover:bg-green-600 text-white primary-action-button">
                    üöÄ Post to BaseApp
                </button>
                <button onclick="downloadMeme(true)" class="primary-action-button control-button w-full py-3 font-bold rounded-lg shadow-lg bg-[--color-primary-action]">
                    ‚¨áÔ∏è Download BaseMeme
                </button>
            </div>


            <div id="upload-panel" class="secondary-panel">
                <div class="flex justify-between items-center border-b border-[--color-accent] pb-3 mb-4 sticky top-0 bg-[--color-dark-bg] z-50 pt-2">
                    <h2 class="text-xl font-bold text-[--color-accent]">üñºÔ∏è Image & Background</h2>
                    <button onclick="closeSecondaryPanel()" class="text-white text-2xl p-2 rounded-full hover:bg-[--color-dark-accent]">&times;</button>
                </div>
                <div class="space-y-4">
                    <input type="file" id="imageUploadInput" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
                    <button onclick="document.getElementById('imageUploadInput').click(); state.uploadMode = 'background';" class="primary-action-button control-button w-full py-3 font-bold rounded-lg">
                        ‚¨ÜÔ∏è Upload & Set as Background
                    </button>
                    <button onclick="document.getElementById('imageUploadInput').click(); state.uploadMode = 'layer';" class="primary-action-button control-button w-full py-3 font-bold rounded-lg">
                        üñºÔ∏è Upload & Add as Layer
                    </button>
                    <hr class="border-[--color-section-bg]">
                    <h3 class="text-lg font-bold text-white">Layer Scale (Selected Image)</h3>
                    <div id="imageControls" class="space-y-2">
                         <label for="scaleSlider" class="block text-sm font-medium text-white">
                            Item Scale: <span id="scaleValue">100%</span>
                        </label>
                        <input type="range" id="scaleSlider" min="0.2" max="3" step="0.1" value="1.0" class="w-full h-2 bg-[--color-accent] rounded-lg appearance-none cursor-pointer range-lg" oninput="updateItemScale(event.target.value)">
                    </div>
                </div>
            </div>

            <div id="templates-panel" class="secondary-panel">
                <div class="flex justify-between items-center border-b border-[--color-accent] pb-3 mb-4 sticky top-0 bg-[--color-dark-bg] z-50 pt-2">
                    <h2 class="text-xl font-bold text-[--color-accent]">üìë Select Template</h2>
                    <button onclick="closeSecondaryPanel()" class="text-white text-2xl p-2 rounded-full hover:bg-[--color-dark-accent]">&times;</button>
                </div>
                <div id="templateSelector" class="grid grid-cols-2 sm:grid-cols-3 gap-3"></div>
            </div>

            <div id="stickers-panel" class="secondary-panel">
                <div class="flex justify-between items-center border-b border-[--color-accent] pb-3 mb-4 sticky top-0 bg-[--color-dark-bg] z-50 pt-2">
                    <h2 class="text-xl font-bold text-[--color-accent]">‚ú® Select Sticker</h2>
                    <button onclick="closeSecondaryPanel()" class="text-white text-2xl p-2 rounded-full hover:bg-[--color-dark-accent]">&times;</button>
                </div>
                <div id="stickerSelector" class="grid grid-cols-3 gap-3"></div>
            </div>
            
            <div id="text-panel" class="secondary-panel">
                <div class="flex justify-between items-center border-b border-[--color-accent] pb-3 mb-4 sticky top-0 bg-[--color-dark-bg] z-50 pt-2">
                    <h2 class="text-xl font-bold text-[--color-accent]">üÖ∞Ô∏è Text Options</h2>
                    <button onclick="closeSecondaryPanel()" class="text-white text-2xl p-2 rounded-full hover:bg-[--color-dark-accent]">&times;</button>
                </div>
                <div class="space-y-4">
                    <button onclick="addTextLayer('NEW TEXT')" class="control-button w-full py-3 bg-[--color-accent] hover:bg-opacity-90 text-black font-bold rounded-lg">
                        ‚ûï Add New Text Layer
                    </button>
                    
                    <div id="textControls" class="space-y-4 p-3 rounded-lg bg-[--color-section-bg]">
                        <h3 class="text-lg font-semibold text-white">Selected Text Layer:</h3>
                        <label for="currentTextContent" class="block text-sm font-medium text-white">Text Content</label>
                        <textarea id="currentTextContent" rows="3" placeholder="Enter text content..." class="w-full p-2 rounded bg-white text-black border border-black focus:ring-[--color-accent] focus:border-[--color-accent] mt-1" oninput="updateCurrentTextContent()"></textarea>
                        
                        <div>
                            <span class="block text-sm font-medium text-white mb-1">Font Family:</span>
                            <div id="fontSelector" class="flex flex-wrap gap-2"></div>
                        </div>
                        
                        <div class="flex flex-wrap items-center gap-3 mb-4">
                            <button id="boldBtn" onclick="toggleStyle('isBold')" class="control-button px-3 py-2 rounded">
                                <span class="font-black">B</span>
                            </button>
                            <button id="italicBtn" onclick="toggleStyle('isItalic')" class="control-button px-3 py-2 rounded">
                                <span class="italic">I</span>
                            </button>
                            <div class="flex items-center space-x-2 bg-white rounded px-2 py-1 border border-black">
                                <label for="textColorInput" class="text-xs text-black cursor-pointer">Color:</label>
                                <input type="color" id="textColorInput" value="#ffffff" class="w-8 h-8 rounded cursor-pointer" oninput="updateTextColor()">
                            </div>
                        </div>
                        
                        <div>
                            <span class="block text-sm font-medium text-white mb-1">Font Size:</span>
                            <select id="fontSizeSelect" onchange="updateFontSize()" class="control-button w-full p-2 rounded text-black">
                                <option value="40">Size: Small</option>
                                <option value="60" selected>Size: Medium</option>
                                <option value="80">Size: Large</option>
                                <option value="100">Size: Extra Large</option>
                                <option value="120">Size: Huge</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div id="drawing-panel" class="secondary-panel">
                 <div class="flex justify-between items-center border-b border-[--color-accent] pb-3 mb-4 sticky top-0 bg-[--color-dark-bg] z-50 pt-2">
                    <h2 class="text-xl font-bold text-[--color-accent]">‚úèÔ∏è Drawing Options</h2>
                    <button onclick="closeSecondaryPanel()" class="text-white text-2xl p-2 rounded-full hover:bg-[--color-dark-accent]">&times;</button>
                </div>
                <div id="drawingControls" class="space-y-4 p-3 rounded-lg bg-[--color-section-bg] border border-[--color-accent]">
                    <button id="drawingModeToggle" onclick="toggleDrawingMode()" class="control-button w-full py-2 font-bold rounded-lg bg-[--color-primary-action] text-white">
                        üî¥ Toggle Drawing Mode (OFF)
                    </button>
                     <div class="flex items-center justify-between gap-3">
                        <div class="flex items-center space-x-2 bg-white rounded px-2 py-1 border border-black">
                            <label for="drawColorInput" class="text-sm text-black cursor-pointer">Color:</label>
                            <input type="color" id="drawColorInput" value="#547cf4" class="w-8 h-8 rounded cursor-pointer" oninput="updateDrawingColor(event.target.value)">
                        </div>

                        <div class="flex items-center space-x-2">
                            <label for="drawSizeSelect" class="text-sm text-white">Size:</label>
                            <select id="drawSizeSelect" onchange="updateDrawingSize(event.target.value)" class="control-button p-2 rounded text-black">
                                <option value="5">Small</option>
                                <option value="15" selected>Medium</option>
                                <option value="30">Large</option>
                                <option value="50">Huge</option>
                            </select>
                        </div>
                    </div>
                    <div>
                        <label for="drawBrushSelect" class="text-sm text-white block mb-1">Brush Style:</label>
                        <select id="drawBrushSelect" onchange="updateDrawingBrush(event.target.value)" class="control-button w-full p-2 rounded text-black">
                            <option value="line" selected>Line (Default)</option>
                            <option value="star">‚≠ê Star</option>
                            <option value="sparks">‚ú® Sparks</option>
                        </select>
                    </div>
                    <button onclick="clearDrawingLayer()" class="control-button w-full py-2 rounded text-black font-bold">
                        üßπ Clear Drawing Layer
                    </button>
                </div>
            </div>

        </div>
    </div>


<script>
    // --- SIMULATED BASE ACCOUNT SDK (IMPORTANT) ---
    const BaseAccountSDK = {
        isConnected: false,
        userInfo: null,
        connect: function() {
            this.userInfo = { 
                userId: 'baseUser123', 
                username: 'BasePoster', 
                baseAccountAddress: '0x123...BaseMemeWallet' 
            };
            this.isConnected = true;
            document.getElementById('baseAppStatus').textContent = `BaseApp Status: Connected as ${this.userInfo.username} (Wallet: ${this.userInfo.baseAccountAddress.substring(0, 6)}...)`;
            console.log('Base Account SDK: Connected to on-chain identity.');
        },
    };
    // -------------------------------------------


    // --- DATA DEFINITIONS & STATE MANAGEMENT ---
    const templates = [
        { id: 't1', name: 'meme1.png', url: './memes/meme1.png', ratio: 4/3 },
        { id: 't2', name: 'meme2.png', url: './memes/meme2.png', ratio: 16/9 },
        { id: 't3', name: 'meme3.png', url: './memes/meme3.png', ratio: 3/4 },
        { id: 't4', name: 'meme4.png', url: './memes/meme4.png', ratio: 1/1 },
        { id: 't5', name: 'meme5.png', url: './memes/meme5.png', ratio: 9/5 },
        { id: 't6', name: 'meme6.png', url: './memes/meme6.png', ratio: 1/1 },
    ];

    const stickers = [
        { id: 's1', name: 'base1.png', url: './base/base1.png' },
        { id: 's2', name: 'base2.png', url: './base/base2.png' },
        { id: 's3', name: 'base3.png', url: './base/base3.png' },
        { id: 's4', name: 'base4.png', url: './base/base4.png' },
        { id: 's5', name: 'base5.png', url: './base/base5.png' },
        { id: 's6', name: 'base6.png', url: './base/base6.png' },
    ];

    const fonts = [
        { id: 'f4', name: 'Global', family: 'AppGlobalFont', fallback: 'sans-serif' },
        { id: 'f1', name: 'Local Font 1', family: 'LocalFont1', fallback: 'sans-serif' },
        { id: 'f2', name: 'Local Font 2', family: 'LocalFont2', fallback: 'serif' },
        { id: 'f3', name: 'Local Font 3', family: 'LocalFont3', fallback: 'cursive' }
    ];

    const canvas = document.getElementById('memeCanvas');
    const ctx = canvas.getContext('2d');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const canvasContainer = document.getElementById('canvas-container');
    const layerResizeHandle = document.getElementById('layerResizeHandle');

    const MIN_CANVAS_SIZE = 100;
    const MAX_CANVAS_SIZE = 1200;
    const MIN_LAYER_SCALE = 0.1;

    let state = {
        selectedTemplateId: templates[0].id,
        currentTemplate: null,
        layers: [],
        selectedLayerIndex: -1,
        isDragging: false,
        isResizing: false, // For Canvas resizing (using the blue handle)
        isLayerResizing: false, // NEW: For Image layer resizing (using the red handle)
        dragStartX: 0,
        dragStartY: 0,
        stickerImages: {},
        isDrawing: false,
        drawingMode: false,
        drawingColor: '#547cf4',
        drawingSize: 15,
        drawingBrush: 'line',
        lastX: 0,
        lastY: 0,
        isCustomBackground: false,
        uploadMode: 'background'
    };

    let initialTemplate = templates.find(t => t.id === state.selectedTemplateId);

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        BaseAccountSDK.connect(); 
        
        canvas.width = 600;
        canvas.height = 600;

        renderTemplateSelector();
        renderStickerSelector();
        renderFontSelector();
        
        loadTemplateImage(initialTemplate.url, initialTemplate.ratio);

        addTextLayer('TOP TEXT', canvas.width / 2, 0.1 * canvas.height);
        addTextLayer('BOTTOM TEXT', canvas.width / 2, 0.9 * canvas.height);

        document.getElementById('drawColorInput').value = state.drawingColor;
        document.getElementById('drawSizeSelect').value = state.drawingSize.toString();
        document.getElementById('drawBrushSelect').value = state.drawingBrush;

        document.fonts.ready.then(() => {
            drawMeme();
        }).catch(e => {
            console.warn("Issue loading local fonts.", e);
            drawMeme();
        });

        setupCanvasInteractions();
        setupDrawingInteractions();
        setupCanvasResizingInteractions();
        setupLayerResizingInteractions(); // NEW: Layer resize setup
        window.addEventListener('resize', resizeCanvases);
    });
    // --- End Initialization ---

    // --- APP DRAWER/MODAL FUNCTIONS ---

    function toggleMainDrawer() {
        const drawer = document.getElementById('app-drawer-container');
        drawer.classList.toggle('active');
        document.querySelectorAll('.secondary-panel').forEach(panel => {
            panel.classList.remove('active');
        });
    }

    function openSecondaryPanel(panelId) {
        document.querySelectorAll('.secondary-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        document.getElementById(`${panelId}-panel`).classList.add('active');
        updateControlPanel(true);
    }

    function closeSecondaryPanel() {
        document.querySelectorAll('.secondary-panel').forEach(panel => {
            panel.classList.remove('active');
        });
    }
    
    // --- CANVAS RESIZING INTERACTIONS ---

    function setupCanvasResizingInteractions() {
        const handle = document.getElementById('resizeHandle');
        
        handle.addEventListener('mousedown', startResizing);
        window.addEventListener('mousemove', resizeCanvas);
        window.addEventListener('mouseup', stopResizing);

        handle.addEventListener('touchstart', startResizing);
        window.addEventListener('touchmove', resizeCanvas);
        window.addEventListener('touchend', stopResizing);
    }

    function startResizing(e) {
        // Only start canvas resize if it's the blue handle
        if (e.target.id === 'resizeHandle') {
            e.preventDefault();
            state.isResizing = true;
            document.body.style.cursor = 'nwse-resize'; 
        }
    }

    function resizeCanvas(e) {
        if (!state.isResizing) return;
        e.preventDefault();

        const containerRect = canvasContainer.getBoundingClientRect();
        
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        // Calculate current scale factor of the displayed canvas
        const currentScale = containerRect.width / canvas.width;
        
        // Calculate new raw pixel dimensions based on the mouse position relative to container's top-left corner,
        // compensating for the CSS scale transform.
        const newWidth = Math.max(MIN_CANVAS_SIZE, Math.min(MAX_CANVAS_SIZE, (clientX - containerRect.left) / currentScale));
        const newHeight = Math.max(MIN_CANVAS_SIZE, Math.min(MAX_CANVAS_SIZE, (clientY - containerRect.top) / currentScale));
        
        const oldWidth = canvas.width;
        const oldHeight = canvas.height;

        // Only proceed if size changed meaningfully
        if (Math.abs(newWidth - oldWidth) < 1 && Math.abs(newHeight - oldHeight) < 1) return;

        canvas.width = newWidth;
        canvas.height = newHeight;

        const widthRatio = newWidth / oldWidth;
        const heightRatio = newHeight / oldHeight;
        
        // Reposition and rescale layers
        state.layers.forEach(layer => {
            layer.x *= widthRatio;
            layer.y *= heightRatio;
            
            const scaleRatio = Math.min(widthRatio, heightRatio);
            if (layer.type === 'text') {
                layer.fontSize *= scaleRatio;
                layer.fontSize = Math.max(10, layer.fontSize); 
            } else if (layer.type === 'image') {
                layer.scale *= scaleRatio;
            }
        });
        
        resizeCanvases();
        drawMeme();
    }

    function stopResizing() {
        if (state.isResizing) {
            state.isResizing = false;
            document.body.style.cursor = 'default';
            resizeCanvases();
            drawMeme();
        }
    }
    
    // --- LAYER RESIZING INTERACTIONS (NEW) ---

    function setupLayerResizingInteractions() {
        layerResizeHandle.addEventListener('mousedown', startLayerResizing);
        window.addEventListener('mousemove', resizeLayer);
        window.addEventListener('mouseup', stopLayerResizing);

        layerResizeHandle.addEventListener('touchstart', startLayerResizing);
        window.addEventListener('touchmove', resizeLayer);
        window.addEventListener('touchend', stopLayerResizing);
    }

    function startLayerResizing(e) {
        if (e.target.id === 'layerResizeHandle' && state.selectedLayerIndex !== -1) {
            e.preventDefault();
            state.isLayerResizing = true;
            document.body.style.cursor = 'nwse-resize';
        }
    }

    function resizeLayer(e) {
        if (!state.isLayerResizing || state.selectedLayerIndex === -1) return;
        e.preventDefault();

        const layer = state.layers[state.selectedLayerIndex];
        if (layer.type !== 'image') return;
        
        const pos = getEventPos(e); // Mouse position in canvas pixels
        
        // Calculate the vector from the layer center to the new mouse position
        const dx = pos.x - layer.x;
        const dy = pos.y - layer.y;

        // Calculate new distance from center to mouse position
        const newDistance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate the current image's diagonal length (normalized to scale 1)
        const diagonal = Math.sqrt(layer.originalW * layer.originalW + layer.originalH * layer.originalH);

        // Determine the target scale based on the distance. 
        // We divide the new distance by half the original diagonal to estimate the scale.
        // The factor of 0.7 is a manual adjustment to make the drag feel proportional to the layer's size.
        const targetScale = Math.max(MIN_LAYER_SCALE, newDistance / (diagonal * 0.7));

        layer.scale = targetScale;
        
        // Update slider visually
        document.getElementById('scaleSlider').value = layer.scale;
        document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;

        drawMeme();
    }

    function stopLayerResizing() {
        if (state.isLayerResizing) {
            state.isLayerResizing = false;
            document.body.style.cursor = 'default';
            drawMeme();
        }
    }


    // --- CORE LOGIC FUNCTIONS ---

    function resizeCanvases() {
        if (!canvas.width || !canvas.height) return;
        
        const previewElement = document.getElementById('preview');
        const containerWidth = previewElement.clientWidth;
        const containerHeight = previewElement.clientHeight;
        
        const maxDisplayWidth = containerWidth * 0.95;
        const maxDisplayHeight = containerHeight * 0.95;

        // Calculate the scale factor to fit the canvas within the viewport area
        const scaleToFitWidth = maxDisplayWidth / canvas.width;
        const scaleToFitHeight = maxDisplayHeight / canvas.height;
        
        const scaleFactor = Math.min(scaleToFitWidth, scaleToFitHeight);

        // Apply raw pixel dimensions for the inner canvases
        drawingCanvas.width = canvas.width;
        drawingCanvas.height = canvas.height;
        drawingCanvas.style.width = `${canvas.width}px`;
        drawingCanvas.style.height = `${canvas.height}px`;

        // Apply raw pixel dimensions and the CSS scale transform to the container for display
        canvasContainer.style.width = `${canvas.width}px`;
        canvasContainer.style.height = `${canvas.height}px`;
        canvasContainer.style.transform = `scale(${scaleFactor})`;

        updateDrawingContext();
        updateLayerResizeHandlePosition(); // Ensure layer handle is positioned correctly after canvas resize
    }
    
    // NEW: Function to position the layer resize handle based on selected layer
    function updateLayerResizeHandlePosition() {
        const layer = state.layers[state.selectedLayerIndex];
        const handle = document.getElementById('layerResizeHandle');

        if (layer && layer.type === 'image') {
            const bbox = layer.bbox;
            
            // Position the handle at the bottom-right corner of the bounding box
            const handleX = bbox.x + bbox.w;
            const handleY = bbox.y + bbox.h;

            // Apply position to the handle element (relative to canvas-container, which acts as the coordinate system origin)
            handle.style.left = `${handleX - 10}px`; // Subtract half handle width
            handle.style.top = `${handleY - 10}px`; // Subtract half handle height
            handle.style.display = 'block';
        } else {
            handle.style.display = 'none';
        }
    }

    function updateDrawingContext() {
        drawingCtx.lineCap = state.drawingBrush === 'line' ? 'round' : 'butt';
        drawingCtx.lineJoin = state.drawingBrush === 'line' ? 'round' : 'miter';
        drawingCtx.strokeStyle = state.drawingColor;
        drawingCtx.lineWidth = state.drawingSize;
    }

    function toggleDrawingMode() {
        state.drawingMode = !state.drawingMode;
        const button = document.getElementById('drawingModeToggle');

        if (state.drawingMode) {
            drawingCanvas.classList.add('active-drawing');
            button.textContent = 'üü¢ Toggle Drawing Mode (ON)';
            button.classList.remove('bg-[--color-primary-action]');
            button.classList.add('bg-red-500');
            state.selectedLayerIndex = -1; 
            updateControlPanel(true); 
            drawMeme(); 
        } else {
            drawingCanvas.classList.remove('active-drawing');
            button.textContent = 'üî¥ Toggle Drawing Mode (OFF)';
            button.classList.add('bg-[--color-primary-action]');
            button.classList.remove('bg-red-500');
        }
    }
    
    function getEventPos(e) {
        const rect = canvasContainer.getBoundingClientRect();
        
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        const currentScale = rect.width / canvas.width;
        
        const scaledX = clientX - rect.left;
        const scaledY = clientY - rect.top;
        
        return {
            x: scaledX / currentScale,
            y: scaledY / currentScale
        };
    }

    function setupCanvasInteractions() {
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseout', handleEnd);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
    }
    
    function handleStart(e) {
        if (state.drawingMode || state.isResizing || state.isLayerResizing) return;
        e.preventDefault();
        const pos = getEventPos(e);
        state.dragStartX = pos.x;
        state.dragStartY = pos.y;

        // Check if user clicked on any layer (iterate backwards to select top-most layer)
        let selectedIndex = -1;
        for (let i = state.layers.length - 1; i >= 0; i--) {
            const layer = state.layers[i];
            const bbox = layer.bbox;
            // Check if click is inside the bounding box
            if (pos.x >= bbox.x && pos.x <= bbox.x + bbox.w && 
                pos.y >= bbox.y && pos.y <= bbox.y + bbox.h) {
                selectedIndex = i;
                break;
            }
        }
        
        state.selectedLayerIndex = selectedIndex;

        if (state.selectedLayerIndex !== -1) {
            state.isDragging = true;
            canvas.style.cursor = 'move';
        } else {
             canvas.style.cursor = 'default';
        }

        updateControlPanel(true);
        drawMeme();
    }

    function handleMove(e) {
        if (!state.isDragging || state.selectedLayerIndex === -1 || state.isResizing || state.isLayerResizing) return;
        e.preventDefault();
        const pos = getEventPos(e);
        const dx = pos.x - state.dragStartX;
        const dy = pos.y - state.dragStartY;

        const layer = state.layers[state.selectedLayerIndex];
        layer.x += dx;
        layer.y += dy;

        state.dragStartX = pos.x;
        state.dragStartY = pos.y;

        drawMeme();
    }

    function handleEnd() {
        state.isDragging = false;
        canvas.style.cursor = 'default';
        drawMeme();
    }

    // --- Image/Template/Layer CRUD and Control Logic (Simplified) ---
    
    function loadTemplateImage(url, ratio) {
        const img = new Image();
        img.onload = () => {
            state.currentTemplate = img;
            state.isCustomBackground = false;
            let targetW = canvas.width; 
            let targetH = targetW / ratio;
            
            if (targetH > MAX_CANVAS_SIZE) { targetH = MAX_CANVAS_SIZE; targetW = targetH * ratio; }
            if (targetW > MAX_CANVAS_SIZE) { targetW = MAX_CANVAS_SIZE; targetH = targetW / ratio; }
            
            const widthRatio = targetW / canvas.width;
            const heightRatio = targetH / canvas.height;

            canvas.width = targetW;
            canvas.height = targetH;
            
            state.layers.forEach(layer => {
                layer.x *= widthRatio;
                layer.y *= heightRatio;
                const scaleRatio = Math.min(widthRatio, heightRatio);
                if (layer.type === 'text') { layer.fontSize *= scaleRatio; } 
                else if (layer.type === 'image') { layer.scale *= scaleRatio; }
            });

            resizeCanvases();
            drawMeme();
        };
        img.src = url;
    }

    // ... (other helper functions like updateDrawingColor, addTextLayer, deleteSelectedLayer etc. are omitted for brevity but remain functional)
    function updateDrawingColor(color) { state.drawingColor = color; updateDrawingContext(); }
    function updateDrawingSize(size) { state.drawingSize = parseInt(size); updateDrawingContext(); }
    function updateDrawingBrush(brush) { state.drawingBrush = brush; updateDrawingContext(); }
    function clearDrawingLayer() { drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); }
    
    function loadCustomTemplateImage(url) {
        state.isCustomBackground = true;
        renderTemplateSelector(); 

        const img = new Image();

        img.onload = () => {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            state.currentTemplate = img;

            let targetW = img.width;
            let targetH = img.height;
            const scaleFactor = Math.min(MAX_CANVAS_SIZE / img.width, MAX_CANVAS_SIZE / img.height, 1);
            targetW = img.width * scaleFactor;
            targetH = img.height * scaleFactor;
            
            const widthRatio = targetW / oldWidth;
            const heightRatio = targetH / oldHeight;

            canvas.width = targetW;
            canvas.height = targetH;
            
            state.layers.forEach(layer => {
                layer.x *= widthRatio;
                layer.y *= heightRatio;
                const scaleRatio = Math.min(widthRatio, heightRatio);
                if (layer.type === 'text') { layer.fontSize *= scaleRatio; } 
                else if (layer.type === 'image') { layer.scale *= scaleRatio; }
            });
            
            resizeCanvases();
            drawMeme();
        };
        img.src = url;
    }
    
    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const imageUrl = e.target.result;
            if (state.uploadMode === 'background') {
                loadCustomTemplateImage(imageUrl);
                closeSecondaryPanel();
            } else if (state.uploadMode === 'layer') {
                addImageLayer(imageUrl, file.name);
                closeSecondaryPanel();
            }
        };
        reader.readAsDataURL(file);
    }

    function selectTemplate(id) {
        state.selectedTemplateId = id;
        state.isCustomBackground = false;
        const selectedTemplate = templates.find(t => t.id === id);

        if (selectedTemplate) {
            renderTemplateSelector();
            loadTemplateImage(selectedTemplate.url, selectedTemplate.ratio);
            closeSecondaryPanel();
        }
    }

    function addPresetImageLayer(url, id) {
        if (state.stickerImages[id]) {
            createImageLayerObject(url, state.stickerImages[id]);
            closeSecondaryPanel();
            drawMeme();
        } else {
            const img = new Image();
            img.onload = () => {
                state.stickerImages[id] = img;
                createImageLayerObject(url, img);
                closeSecondaryPanel();
                drawMeme();
            };
            img.src = url;
        }
    }

    function addImageLayer(url, name) {
        const img = new Image();
        img.onload = () => {
            createImageLayerObject(url, img, name);
            drawMeme();
        };
        img.src = url;
    }

    function createImageLayerObject(url, imgObject, name = '') {
        const newLayer = {
            type: 'image', id: Date.now(), itemUrl: url, name: name,
            x: canvas.width / 2, y: canvas.height / 2, scale: 1.0, rotation: 0,
            flipX: false, flipY: false, imageObject: imgObject,
            originalW: imgObject.width, originalH: imgObject.height,
            bbox: { x: 0, y: 0, w: 0, h: 0 }
        };
        
        const MAX_LAYER_DIMENSION_RATIO = 0.5;
        if (newLayer.originalW > canvas.width * MAX_LAYER_DIMENSION_RATIO || newLayer.originalH > canvas.height * MAX_LAYER_DIMENSION_RATIO) {
            newLayer.scale = Math.min(
                (canvas.width * MAX_LAYER_DIMENSION_RATIO) / newLayer.originalW,
                (canvas.height * MAX_LAYER_DIMENSION_RATIO) / newLayer.originalH
            );
        }
        
        state.layers.push(newLayer);
        state.selectedLayerIndex = state.layers.length - 1;
        updateControlPanel(true);
    }
    
    function addTextLayer(content = 'New Text', x = canvas.width / 2, y = canvas.height / 2) {
        const newLayer = {
            type: 'text', id: Date.now(), content: content.toUpperCase(),
            x: x, y: y, isBold: content.includes('TOP') || content.includes('BOTTOM') ? true : false,
            isItalic: false, fontSize: 60, color: '#FFFFFF', fontId: fonts[0].id,
            rotation: 0, flipX: false, flipY: false, bbox: { x: 0, y: 0, w: 0, h: 0 }
        };
        state.layers.push(newLayer);
        state.selectedLayerIndex = state.layers.length - 1;
        updateControlPanel(true);
        drawMeme();
    }

    function deleteSelectedLayer() {
        if (state.selectedLayerIndex < 0) return;
        state.layers.splice(state.selectedLayerIndex, 1);
        state.selectedLayerIndex = -1;
        updateControlPanel(true);
        drawMeme();
    }
    
    function updateRotation(degrees) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer) {
            layer.rotation = parseInt(degrees);
            document.getElementById('rotationValue').textContent = `${layer.rotation}¬∞`;
            drawMeme();
        }
    }

    function toggleFlip(axis) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer) {
            layer[axis] = !layer[axis];
            document.getElementById(`${axis}Btn`).classList.toggle('selected-item', layer[axis]);
            drawMeme();
        }
    }
    
    function updateItemScale(scale) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'image') {
            layer.scale = parseFloat(scale);
            document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;
            drawMeme();
        }
    }
    
    function updateCurrentTextContent() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer.content = document.getElementById('currentTextContent').value.toUpperCase();
            drawMeme();
        }
    }

    function toggleStyle(style) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer[style] = !layer[style];
            document.getElementById(`${style.replace('is', '').toLowerCase()}Btn`).classList.toggle('selected-item', layer[style]);
            drawMeme();
        }
    }

    function updateTextColor() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer.color = document.getElementById('textColorInput').value;
            drawMeme();
        }
    }

    function updateFontSize() {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer.fontSize = parseInt(document.getElementById('fontSizeSelect').value);
            drawMeme();
        }
    }
    
    function selectFont(id) {
        const layer = state.layers[state.selectedLayerIndex];
        if (layer && layer.type === 'text') {
            layer.fontId = id;
            updateControlPanel(true);
            drawMeme();
        }
    }

    function drawMeme() {
        if (!state.currentTemplate) { ctx.clearRect(0, 0, canvas.width, canvas.height); }
        else { ctx.drawImage(state.currentTemplate, 0, 0, canvas.width, canvas.height); }
        
        state.layers.forEach((layer, index) => {
            ctx.save();
            ctx.translate(layer.x, layer.y);
            ctx.rotate(layer.rotation * Math.PI / 180);
            const scaleX = layer.flipX ? -1 : 1;
            const scaleY = layer.flipY ? -1 : 1;
            ctx.scale(scaleX, scaleY);
            let bbox = { w: 0, h: 0 }; // Bbox relative to layer's (0,0) after rotation
            
            if (layer.type === 'text') {
                const fontConfig = fonts.find(f => f.id === layer.fontId);
                const fontFamily = fontConfig ? `'${fontConfig.family}', ${fontConfig.fallback}` : 'sans-serif';
                const style = (layer.isBold ? 'bold ' : '') + (layer.isItalic ? 'italic ' : '');
                ctx.font = `${style}${layer.fontSize}px ${fontFamily}`;
                ctx.fillStyle = layer.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = layer.fontSize / 15;
                const lines = layer.content.split('\n');
                let maxLineWidth = 0;
                let lineSpacing = layer.fontSize * 1.2;
                lines.forEach((line, i) => {
                    const yOffset = (i - (lines.length - 1) / 2) * lineSpacing;
                    ctx.strokeText(line, 0, yOffset); 
                    ctx.fillText(line, 0, yOffset);
                    maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
                });
                bbox.w = maxLineWidth + ctx.lineWidth * 2;
                bbox.h = lines.length * lineSpacing + ctx.lineWidth * 2;
                
                // Draw selection box *before* reversing rotation/translation
                if (index === state.selectedLayerIndex && !state.isDragging) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(-bbox.w / 2 - 2, -bbox.h / 2 - 2, bbox.w + 4, bbox.h + 4);
                }
            } else if (layer.type === 'image') {
                const img = layer.imageObject;
                const renderW = img.width * layer.scale;
                const renderH = img.height * layer.scale;
                ctx.drawImage(img, -renderW / 2, -renderH / 2, renderW, renderH);
                bbox.w = renderW;
                bbox.h = renderH;
                
                // Draw selection box *before* reversing rotation/translation
                if (index === state.selectedLayerIndex && !state.isDragging && !state.isLayerResizing) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(-bbox.w / 2 - 2, -bbox.h / 2 - 2, bbox.w + 4, bbox.h + 4);
                }
            }
            
            ctx.restore();
            
            // Recalculate Bounding Box (Axis-Aligned, for hit detection)
            // Note: This is a simplification and doesn't account for rotation correctly, 
            // but is fine for simple hit-testing on the center point for dragging.
            layer.bbox = {
                x: layer.x - Math.abs(bbox.w * scaleX) / 2,
                y: layer.y - Math.abs(bbox.h * scaleY) / 2,
                w: Math.abs(bbox.w * scaleX),
                h: Math.abs(bbox.h * scaleY)
            };
        });
        
        updateLayerResizeHandlePosition(); // Update handle location after draw
    }
    
    // --- Render Functions (Omitted for brevity, but exist below) ---

    function renderTemplateSelector() {
        const container = document.getElementById('templateSelector');
        container.innerHTML = templates.map(t => `
            <div
                onclick="selectTemplate('${t.id}')"
                class="control-button cursor-pointer p-1 rounded-lg border-2 border-transparent transition duration-150 ease-in-out ${state.selectedTemplateId === t.id && !state.isCustomBackground ? 'selected-item' : 'hover:border-[--color-accent] bg-[--color-general-button]'}"
                data-id="${t.id}"
            >
                <img src="${t.url}" alt="${t.name}" class="w-full h-auto object-cover rounded-md aspect-video" onerror="this.onerror=null; this.src='https://placehold.co/150x85/1f2937/9ca3af?text=/${t.url.split('/')[1]}/Image'">
                <p class="text-xs text-center mt-1 text-black">${t.name}</p>
            </div>
        `).join('');
    }

    function renderStickerSelector() {
        const container = document.getElementById('stickerSelector');
        container.innerHTML = stickers.map(s => `
            <div
                onclick="addPresetImageLayer('${s.url}', '${s.id}')"
                class="control-button cursor-pointer p-1 rounded-lg border-2 border-transparent hover:border-[--color-accent] transition duration-150 ease-in-out bg-[--color-general-button]"
                data-id="${s.id}"
            >
                <img src="${s.url}" alt="${s.name}" class="w-full h-auto object-cover rounded-md aspect-square" onerror="this.onerror=null; this.src='https://placehold.co/150x150/1f2937/9ca3af?text=/${s.url.split('/')[1]}/Item'">
                <p class="text-xs text-center mt-1 text-black">${s.name}</p>
            </div>
        `).join('');
    }

    function renderFontSelector() {
        const container = document.getElementById('fontSelector');
        const selectedFontId = state.selectedLayerIndex !== -1 && state.layers[state.selectedLayerIndex].type === 'text' ? state.layers[state.selectedLayerIndex].fontId : null;
        container.innerHTML = fonts.map(f => `
            <button
                onclick="selectFont('${f.id}')"
                class="control-button px-3 py-1 text-sm rounded font-medium hover:bg-gray-200 ${selectedFontId === f.id ? 'selected-item' : ''}"
                id="font-${f.id}"
                style="font-family: '${f.family}', ${f.fallback};"
            >
                ${f.name}
            </button>
        `).join('');
    }

    function updateControlPanel(forceUpdate = false) {
        const index = state.selectedLayerIndex;
        const layer = state.layers[index];
        const commonControls = document.getElementById('commonControls');
        const transformationControls = document.getElementById('transformationControls');
        const layerTypeDisplay = document.getElementById('currentLayerTypeDisplay');
        const textControls = document.getElementById('textControls');
        const imageControls = document.getElementById('imageControls');
        
        commonControls.classList.add('hidden');
        transformationControls.classList.add('hidden');
        layerTypeDisplay.textContent = 'None';
        
        textControls.style.display = 'none';
        imageControls.style.display = 'none';
        
        if (index >= 0 && layer) {
            commonControls.classList.remove('hidden');
            transformationControls.classList.remove('hidden');
            layerTypeDisplay.textContent = `${layer.type.charAt(0).toUpperCase() + layer.type.slice(1)} Layer ${index + 1}`;
            
            document.getElementById('rotationSlider').value = layer.rotation;
            document.getElementById('rotationValue').textContent = `${layer.rotation}¬∞`;
            document.getElementById('flipXBtn').classList.toggle('selected-item', layer.flipX);
            document.getElementById('flipYBtn').classList.toggle('selected-item', layer.flipY);
            
            if (layer.type === 'text') {
                textControls.style.display = 'block';
                document.getElementById('currentTextContent').value = layer.content;
                document.getElementById('boldBtn').classList.toggle('selected-item', layer.isBold);
                document.getElementById('italicBtn').classList.toggle('selected-item', layer.isItalic);
                document.getElementById('fontSizeSelect').value = layer.fontSize.toString();
                document.getElementById('textColorInput').value = layer.color || '#FFFFFF';
                renderFontSelector(); 
            } 
            else if (layer.type === 'image') {
                imageControls.style.display = 'block';
                document.getElementById('scaleSlider').value = layer.scale;
                document.getElementById('scaleValue').textContent = `${Math.round(layer.scale * 100)}%`;
            }
        }
        updateLayerResizeHandlePosition(); // Crucial to update handle display/position
    }

    // --- BASEAPP POSTING FUNCTION (Omitted for brevity) ---
    function downloadMeme(showAlert = false) {
        drawMeme(); 
        const dataURL = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'BaseMeme_' + Date.now() + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        if (showAlert) {
            alert("Your BaseMeme has been downloaded!");
        }
        return dataURL;
    }

    async function postToBaseApp() {
        if (!BaseAccountSDK.isConnected) {
            alert("BaseApp connection not established. Please try refreshing the app.");
            return;
        }
        
        drawMeme(); 

        const postText = `baseposting everyday\n[put here your meme]`;
        const fileName = 'BaseMeme_' + Date.now() + '.png';

        try {
            const file = await new Promise(resolve => {
                canvas.toBlob(blob => {
                    resolve(new File([blob], fileName, { type: 'image/png' }));
                }, 'image/png');
            });

            const shareData = {
                title: 'BaseMeme',
                text: postText,
                files: [file],
            };

            if (navigator.share && navigator.canShare(shareData)) {
                await navigator.share(shareData);
                console.log('Shared successfully using Web Share API.');
                return;
            }
            
            throw new Error("Web Share API not supported or sharing files failed.");

        } catch (error) {
            console.warn('Sharing failed, falling back to download/clipboard:', error);
            
            downloadMeme(false); 
            
            navigator.clipboard.writeText(postText).then(() => {
                alert(
                    `Sharing failed or Web Share API not supported on this device/browser.\n\n` + 
                    `‚úÖ Meme image has been downloaded.\n` + 
                    `‚úÖ Post text has been copied to your clipboard.\n\n` +
                    `Please open the Base App and paste the text/attach the image manually.`
                );
            }).catch(err => {
                alert("Could not copy text to clipboard. Please copy manually and attach the image.");
            });
        }
    }
</script>
</body>
</html>
