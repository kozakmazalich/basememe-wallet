<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BaseMeme Layer Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>

    <style>
        /* Define Custom Colors */
        :root {
            --color-dark-bg: #302c44;
            --color-accent: #547cf4;
            --color-primary-action: #4362e5;
            --color-general-button: #a09bc5;
            --color-dark-accent: #0e1f72;
            --color-section-bg: #6f66a8;
            --color-white: #FFFFFF;
            --color-black: #000000;
        }

        /* --- LOCAL FONT LOADING --- */
        @font-face {
            font-family: 'AppGlobalFont';
            src: url('./fonts/font4.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont1';
            src: url('./fonts/font1.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont2';
            src: url('./fonts/font2.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'LocalFont3';
            src: url('./fonts/font3.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* Base styles */
        body {
            font-family: 'AppGlobalFont', sans-serif;
            background-color: var(--color-dark-bg);
        }

        /* General Button Styling */
        .control-button {
            transition: all 0.15s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: var(--color-black);
            background-color: var(--color-general-button);
        }
        .control-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            background-color: #8c90b6;
        }
        .control-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        .primary-action-button {
            background-color: var(--color-primary-action);
            color: var(--color-white);
        }
        .primary-action-button:hover {
            background-color: var(--color-dark-accent);
        }
        .selected-item {
            border-width: 4px;
            border-color: var(--color-accent) !important;
        }

        /* Scrollbar styles (omitted for brevity, assume they are carried over) */
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-thumb { background: var(--color-accent); border-radius: 4px; }
        #controls::-webkit-scrollbar-track { background: var(--color-dark-bg); }

        .canvas-container {
            /* Ensures the container respects max width/height */
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* Canvas z-index and interaction styles */
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            cursor: default;
            pointer-events: none;
        }
        #drawingCanvas.active-drawing {
            pointer-events: auto;
            cursor: crosshair;
        }

        /* ---------------------------------------------------- */
        /* --- FIX: STICKY MENU AND STABLE CANVAS ON DESKTOP --- */
        /* ---------------------------------------------------- */
        @media (min-width: 1024px) {
            /* 1. Make the body take full height of the viewport on desktop */
            body {
                height: 100vh;
                overflow: hidden; /* Prevent main page scroll on desktop */
            }

            /* 2. Fix the control panel to the left, enabling internal scrolling */
            #controls {
                position: fixed !important; /* Override Tailwind's lg: order */
                top: 0;
                left: 0;
                height: 100vh;
                width: 33.3333%; /* lg:w-1/3 */
                overflow-y: auto; /* Enable internal scrolling */
                z-index: 20; /* Ensure it stays on top */
            }

            /* 3. Push the canvas content over by the width of the fixed sidebar */
            #preview-wrapper {
                margin-left: 33.3333%; /* 1/3 width offset */
                width: 66.6667%; /* lg:w-2/3 */
                min-height: 100vh; /* Takes remaining height */
                overflow-y: auto; /* In case the canvas content exceeds viewport height */

                /* Ensure the preview area is the primary scrollable content */
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
        }
        /* ---------------------------------------------------- */
    </style>
</head>
<body class="min-h-screen flex flex-col">

<header class="w-full bg-[--color-dark-bg] p-4 lg:p-6 text-white border-b border-[--color-accent] order-0 lg:order-0">
    <div class="flex flex-col lg:flex-row justify-between items-center gap-4">
        <h1 class="text-3xl font-extrabold text-[--color-accent]">BaseMeme Layer Editor</h1>
        <div class="flex items-center space-x-4">
            <p id="walletStatus" class="text-sm font-semibold text-red-500">Status: Disconnected</p>
            <button id="connectWalletBtn" class="primary-action-button control-button px-4 py-2 font-bold rounded-lg bg-red-500 hover:bg-red-600">
                Connect Wallet
            </button>
        </div>
    </div>
</header>


<div id="controls" class="w-full lg:w-1/3 bg-[--color-dark-bg] text-white p-4 lg:p-6 flex flex-col space-y-4 lg:space-y-6 order-2 lg:order-1 z-10">

    <h1 class="hidden lg:block text-3xl font-extrabold text-[--color-accent] border-b border-[--color-accent] pb-3 mb-4">Controls</h1>

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">1. Upload Images</h2>
        <div class="flex flex-col space-y-2">
            <input type="file" id="imageUploadInput" accept="image/*" class="hidden" onchange="handleImageUpload(event)">

            <button onclick="document.getElementById('imageUploadInput').click(); state.uploadMode = 'background';" class="primary-action-button control-button w-full py-2 font-bold rounded-lg">
                ‚¨ÜÔ∏è Upload & Set as Background
            </button>

            <button onclick="document.getElementById('imageUploadInput').click(); state.uploadMode = 'layer';" class="primary-action-button control-button w-full py-2 font-bold rounded-lg">
                üñºÔ∏è Upload & Add as Layer (Movable/Rotatable)
            </button>
            <p class="text-sm text-gray-200">The layered image can be selected and edited below.</p>
        </div>
    </section>

    <hr class="border-[--color-accent]">

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">2. Template Background (Folder: /memes)</h2>
        <div id="templateSelector" class="grid grid-cols-3 gap-2">
        </div>
    </section>

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">3. Add Sticker Item (Folder: /base)</h2>
        <div id="stickerSelector" class="grid grid-cols-3 gap-2">
        </div>
    </section>

    <section>
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">4. Drawing Tool (Paint)</h2>
        <div id="drawingControls" class="space-y-4 p-3 rounded-lg bg-[--color-section-bg] border border-[--color-accent]">

            <button id="drawingModeToggle" onclick="toggleDrawingMode()" class="control-button w-full py-2 font-bold rounded-lg bg-[--color-primary-action] text-white">
                üî¥ Toggle Drawing Mode (OFF)
            </button>

            <div class="flex items-center justify-between gap-3">
                <div class="flex items-center space-x-2 bg-white rounded px-2 py-1 border border-black">
                    <label for="drawColorInput" class="text-sm text-black cursor-pointer">Color:</label>
                    <input type="color" id="drawColorInput" value="#547cf4" class="w-8 h-8 rounded cursor-pointer" oninput="updateDrawingColor(event.target.value)">
                </div>

                <div class="flex items-center space-x-2">
                    <label for="drawSizeSelect" class="text-sm text-white">Size:</label>
                    <select id="drawSizeSelect" onchange="updateDrawingSize(event.target.value)" class="control-button p-2 rounded text-black">
                        <option value="5">Small</option>
                        <option value="15" selected>Medium</option>
                        <option value="30">Large</option>
                        <option value="50">Huge</option>
                    </select>
                </div>
            </div>

            <div>
                <label for="drawBrushSelect" class="text-sm text-white block mb-1">Brush Style:</label>
                <select id="drawBrushSelect" onchange="updateDrawingBrush(event.target.value)" class="control-button w-full p-2 rounded text-black">
                    <option value="line" selected>Line (Default)</option>
                    <option value="star">‚≠ê Star</option>
                    <option value="sparks">‚ú® Sparks</option>
                </select>
            </div>

            <button onclick="clearDrawingLayer()" class="control-button w-full py-2 rounded text-black font-bold">
                üßπ Clear Drawing Layer
            </button>
        </div>
    </section>

    <hr class="border-[--color-accent]">

    <section class="flex-grow pt-4">
        <h2 class="text-xl font-bold mb-3 text-[--color-accent]">5. Edit Selected Layer (<span id="currentLayerTypeDisplay">None</span>)</h2>

        <p class="text-sm text-gray-200 mb-2">Tap/click layer on image to edit. **(Must turn OFF Drawing Mode)**</p>

        <div id="contextualControls" class="space-y-4">

            <div id="textControls" class="space-y-4 hidden">
                <label for="currentTextContent" class="block text-sm font-medium text-white">Text Content</label>
                <textarea id="currentTextContent" rows="3" placeholder="Enter text content..." class="w-full p-2 rounded bg-white text-black border border-black focus:ring-[--color-accent] focus:border-[--color-accent] mt-1" oninput="updateCurrentTextContent()"></textarea>

                <div>
                    <span class="block text-sm font-medium text-white mb-1">Font Family (Folder: /fonts):</span>
                    <div id="fontSelector" class="flex flex-wrap gap-2"></div>
                </div>

                <div class="flex flex-wrap items-center gap-3 mb-4">
                    <button id="boldBtn" onclick="toggleStyle('isBold')" class="control-button px-3 py-2 rounded">
                        <span class="font-black">B</span>
                    </button>
                    <button id="italicBtn" onclick="toggleStyle('isItalic')" class="control-button px-3 py-2 rounded">
                        <span class="italic">I</span>
                    </button>

                    <div class="flex items-center space-x-2 bg-white rounded px-2 py-1 border border-black">
                        <label for="textColorInput" class="text-xs text-black cursor-pointer">Color:</label>
                        <input type="color" id="textColorInput" value="#ffffff" class="w-8 h-8 rounded cursor-pointer" oninput="updateTextColor()">
                    </div>
                </div>

                <div>
                    <span class="block text-sm font-medium text-white mb-1">Font Size:</span>
                    <select id="fontSizeSelect" onchange="updateFontSize()" class="control-button w-full p-2 rounded text-black">
                        <option value="40">Size: Small</option>
                        <option value="60" selected>Size: Medium</option>
                        <option value="80">Size: Large</option>
                        <option value="100">Size: Extra Large</option>
                        <option value="120">Size: Huge</option>
                    </select>
                </div>

                <h3 class="text-lg font-semibold text-white border-t border-[--color-accent] pt-3">Transformations</h3>
            </div>

            <div id="transformationControls" class="space-y-4 hidden">
                <div>
                    <label for="rotationSlider" class="block text-sm font-medium text-white">
                        Rotation: <span id="rotationValue">0¬∞</span>
                    </label>
                    <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0" class="w-full h-2 bg-[--color-accent] rounded-lg appearance-none cursor-pointer range-lg" oninput="updateRotation(event.target.value)">
                </div>

                <div class="flex flex-wrap items-center gap-3">
                    <button id="flipXBtn" onclick="toggleFlip('flipX')" class="control-button px-3 py-2 rounded">
                        ‚ÜîÔ∏è Flip X (Mirror)
                    </button>
                    <button id="flipYBtn" onclick="toggleFlip('flipY')" class="control-button px-3 py-2 rounded">
                        ‚ÜïÔ∏è Flip Y
                    </button>
                </div>
            </div>

            <div id="imageControls" class="space-y-4 hidden">
                <label for="scaleSlider" class="block text-sm font-medium text-white">
                    Item Scale: <span id="scaleValue">100%</span>
                </label>
                <input type="range" id="scaleSlider" min="0.2" max="3" step="0.1" value="1.0" class="w-full h-2 bg-[--color-accent] rounded-lg appearance-none cursor-pointer range-lg" oninput="updateItemScale(event.target.value)">
                <h3 class="text-lg font-semibold text-white border-t border-[--color-accent] pt-3">Transformations</h3>
            </div>

            <div id="commonControls" class="hidden">
                <button onclick="addTextLayer('NEW TEXT')" class="control-button w-full py-2 bg-[--color-accent] hover:bg-opacity-90 text-black font-bold rounded-lg mb-4">
                    ‚ûï Add New Text Layer
                </button>
                <button onclick="deleteSelectedLayer()" class="control-button w-full py-2 rounded bg-red-500 hover:bg-red-600 text-white font-bold">
                    üóëÔ∏è Delete Selected Layer
                </button>
            </div>
        </div>
    </section>

    <button id="postMemeBtn" disabled class="primary-action-button control-button w-full py-3 font-bold rounded-lg shadow-lg mt-6 bg-green-500 hover:bg-green-600">
        ‚úÖ Post Meme to BaseApp
    </button>
    <button onclick="downloadMeme()" class="primary-action-button control-button w-full py-3 font-bold rounded-lg shadow-lg">
        ‚¨áÔ∏è Download BaseMeme
    </button>
</div>

<div id="preview-wrapper" class="w-full order-1 lg:order-2">
    <div id="preview" class="w-full lg:w-full flex items-center justify-center p-4 lg:p-8 z-20 relative">
        <div class="bg-[--color-accent] p-2 lg:p-4 rounded-xl shadow-2xl max-w-full max-h-full canvas-container">
            <canvas id="memeCanvas" class="w-full h-full rounded-lg border-4 border-[--color-accent] bg-[--color-accent] shadow-xl touch-none"></canvas>
            <canvas id="drawingCanvas" class="rounded-lg touch-none"></canvas>
        </div>
    </div>
</div>

<script>
    // --- DATA DEFINITIONS (continued) ---
    const templates = [
        { id: 't1', name: 'meme1.png', url: './memes/meme1.png', ratio: 4/3 },
        { id: 't2', name: 'meme2.png', url: './memes/meme2.png', ratio: 16/9 },
        { id: 't3', name: 'meme3.png', url: './memes/meme3.png', ratio: 3/4 },
        { id: 't4', name: 'meme4.png', url: './memes/meme4.png', ratio: 1/1 },
        { id: 't5', name: 'meme5.png', url: './memes/meme5.png', ratio: 9/5 },
        { id: 't6', name: 'meme6.png', url: './memes/meme6.png', ratio: 1/1 },
    ];

    const stickers = [
        { id: 's1', name: 'base1.png', url: './base/base1.png' },
        { id: 's2', name: 'base2.png', url: './base/base2.png' },
        { id: 's3', name: 'base3.png', url: './base/base3.png' },
        { id: 's4', name: 'base4.png', url: './base/base4.png' },
        { id: 's5', name: 'base5.png', url: './base/base5.png' },
        { id: 's6', name: 'base6.png', url: './base/base6.png' },
    ];

    const fonts = [
        { id: 'f4', name: 'font4.otf (Global)', family: 'AppGlobalFont', fallback: 'sans-serif' },
        { id: 'f1', name: 'font1.ttf', family: 'LocalFont1', fallback: 'sans-serif' },
        { id: 'f2', name: 'font2.ttf', family: 'LocalFont2', fallback: 'serif' },
        { id: 'f3', name: 'font3.ttf', family: 'LocalFont3', fallback: 'cursive' }
    ];

    // --- STATE MANAGEMENT ---
    const canvas = document.getElementById('memeCanvas');
    const ctx = canvas.getContext('2d');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const MAX_CANVAS_WIDTH = 800;
    const MAX_CANVAS_HEIGHT = 800;

    let state = {
        selectedTemplateId: templates[0].id,
        currentTemplate: null,
        layers: [],
        selectedLayerIndex: -1,
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        stickerImages: {},
        isDrawing: false,
        drawingMode: false,
        drawingColor: '#547cf4',
        drawingSize: 15,
        drawingBrush: 'line',
        lastX: 0,
        lastY: 0,
        isCustomBackground: false,
        uploadMode: 'background'
    };

    let initialTemplate = templates.find(t => t.id === state.selectedTemplateId);

    // --- WALLET/BASEAPP INTEGRATION FUNCTIONS (Inserted from the block above) ---
    // (The `BaseApp` object, `wallet` object, and the functions `connectWallet`,
    // `disconnectWallet`, `updateWalletStatus`, `postMeme`, and `getFinalMemeCanvas`
    // should be copied and placed here or at the very beginning of the <script> tag.)
    // ********************************************************************************

    // START OF INTEGRATED JAVASCRIPT

    // 1. Placeholder for BaseApp SDK Interface (must be provided by the actual BaseApp platform)
    const BaseApp = {
        // This is a simulated object. In a real mini-app environment, this might be
        // available as a global variable (e.g., window.BaseAppSDK) or imported.
        SDK: {
            // Function to create a new post with a base64 image and optional metadata
            postContent: async (base64Image, contentText = 'Meme created with BaseMeme Layer Editor!', metadata = {}) => {
                console.log("BASEAPP_SDK: Attempting to post content...");

                // Simulation
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve({
                            success: true,
                            postId: 'BAP-' + Date.now(),
                            message: "Meme successfully posted to BaseApp! (Simulated)"
                        });
                    }, 1500);
                });
            }
        }
    };

    // 2. Wallet Connection (using Ethers.js and MetaMask/Injected Provider as a standard example)
    let wallet = {
        provider: null,
        signer: null,
        address: null,
        isConnected: false,
    };

    async function connectWallet() {
        if (typeof window.ethereum === 'undefined') {
            alert("MetaMask (or compatible wallet) is not installed. Please install it to connect.");
            return;
        }

        try {
            // Request account access
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });

            // Initialize Ethers provider and signer
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();

            wallet.provider = provider;
            wallet.signer = signer;
            wallet.address = accounts[0];
            wallet.isConnected = true;

            updateWalletStatus(wallet.address);

            console.log("Wallet Connected:", wallet.address);

            // Optional: Listen for account changes
            window.ethereum.on('accountsChanged', (newAccounts) => {
                if (newAccounts.length === 0) {
                    disconnectWallet();
                } else {
                    wallet.address = newAccounts[0];
                    updateWalletStatus(wallet.address);
                }
            });

        } catch (error) {
            console.error("User rejected wallet connection or error occurred:", error);
            alert("Wallet connection failed. See console for details.");
            updateWalletStatus(null, false);
        }
    }

    function disconnectWallet() {
        wallet.isConnected = false;
        wallet.address = null;
        updateWalletStatus(null, false);
        console.log("Wallet Disconnected.");
    }

    function updateWalletStatus(address, isConnected = true) {
        const statusElement = document.getElementById('walletStatus');
        const connectBtn = document.getElementById('connectWalletBtn');
        const postBtn = document.getElementById('postMemeBtn'); // Get post button

        if (isConnected && address) {
            statusElement.textContent = `Connected: ${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
            statusElement.classList.remove('text-red-500');
            statusElement.classList.add('text-green-500');
            connectBtn.textContent = 'Wallet Connected';
            connectBtn.disabled = true;
            connectBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            connectBtn.classList.remove('bg-red-500');
            postBtn.disabled = false; // Enable posting when connected
        } else {
            statusElement.textContent = 'Status: Disconnected';
            statusElement.classList.add('text-red-500');
            statusElement.classList.remove('text-green-500');
            connectBtn.textContent = 'Connect Wallet';
            connectBtn.disabled = false;
            connectBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
            connectBtn.classList.add('bg-red-500');
            postBtn.disabled = true; // Disable posting when disconnected
        }
    }

    // 3. Post Meme Function
    async function postMeme() {
        if (!wallet.isConnected) {
            alert("Please connect your wallet before posting the meme.");
            return;
        }

        if (!state.currentTemplate && !state.isCustomBackground) {
            alert("Please select a template or upload an image first.");
            return;
        }

        // A. Disable button and show loading state
        const postBtn = document.getElementById('postMemeBtn');
        const originalText = postBtn.textContent;
        postBtn.disabled = true;
        postBtn.textContent = 'üöÄ Posting...';

        // B. Finalize the meme and get the Base64 image data
        const finalCanvas = await getFinalMemeCanvas();
        // Remove the data URL prefix for a cleaner base64 string, if needed by the API
        const base64Image = finalCanvas.toDataURL('image/png').split(',')[1];

        // C. Call the BaseApp SDK
        try {
            const result = await BaseApp.SDK.postContent(
                base64Image,
                "My fresh meme created in the BaseMeme Layer Editor mini-app!",
                {
                    layerCount: state.layers.length,
                    creatorAddress: wallet.address
                }
            );

            if (result.success) {
                alert(`Meme posted successfully! Post ID: ${result.postId}`);
            } else {
                throw new Error(result.message || "Failed to post meme.");
            }

        } catch (error) {
            console.error("Meme Posting Error:", error);
            alert(`Failed to post meme to BaseApp. Error: ${error.message}`);
        } finally {
            // D. Re-enable button and reset text
            postBtn.textContent = originalText;
            postBtn.disabled = false;
            updateWalletStatus(wallet.address, wallet.isConnected); // Re-run to ensure post button is correctly enabled/disabled
        }
    }

    /**
     * Creates a new canvas that merges the meme content canvas and the drawing canvas.
     */
    function getFinalMemeCanvas() {
        return new Promise(resolve => {
            // Create an invisible temporary canvas with the same dimensions
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // Draw the main meme canvas content (which includes the background and layers)
            finalCtx.drawImage(canvas, 0, 0);

            // Draw the drawing canvas content on top
            finalCtx.drawImage(drawingCanvas, 0, 0);

            resolve(finalCanvas);
        });
    }

    // END OF INTEGRATED JAVASCRIPT (The rest of the user's provided JS continues below)

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // ... (rest of existing initialization logic) ...
        renderTemplateSelector();
        renderStickerSelector();
        renderFontSelector();
        loadTemplateImage(initialTemplate.url, initialTemplate.ratio);

        // Initial text layers
        addTextLayer('TOP TEXT', MAX_CANVAS_WIDTH / 2, 0.1 * MAX_CANVAS_HEIGHT);
        addTextLayer('BOTTOM TEXT', MAX_CANVAS_WIDTH / 2, 0.9 * MAX_CANVAS_HEIGHT);

        // Set initial drawing controls
        document.getElementById('drawColorInput').value = state.drawingColor;
        document.getElementById('drawSizeSelect').value = state.drawingSize.toString();
        document.getElementById('drawBrushSelect').value = state.drawingBrush;

        document.fonts.ready.then(() => {
            drawMeme();
        }).catch(e => {
            console.warn("Issue loading local fonts.", e);
            drawMeme();
        });

        setupCanvasInteractions();
        setupDrawingInteractions();
        window.addEventListener('resize', resizeCanvases);

        // --- NEW WALLET/POST SETUP ---
        document.getElementById('connectWalletBtn').addEventListener('click', connectWallet);
        document.getElementById('postMemeBtn').addEventListener('click', postMeme);

        updateWalletStatus(null, false);
    });

    // --- (rest of JavaScript functions: resizeCanvases, toggleDrawingMode, render functions, layer manipulation, drawing, etc., must be present here) ---

    function loadTemplateImage(url, ratio) {
        // ... (function logic here) ...
        const img = new Image();
        img.onload = () => {
            state.currentTemplate = img;

            let targetW = MAX_CANVAS_WIDTH;
            let targetH = MAX_CANVAS_WIDTH / ratio;

            if (targetH > MAX_CANVAS_HEIGHT) {
                targetH = MAX_CANVAS_HEIGHT;
                targetW = MAX_CANVAS_HEIGHT * ratio;
            }

            canvas.width = targetW;
            canvas.height = targetH;

            resizeCanvases();
            drawMeme();
        };
        img.onerror = () => {
            console.error("Could not load template image:", url);
            // Fallback to a square canvas if image fails
            canvas.width = 600;
            canvas.height = 600;
            state.currentTemplate = null;
            resizeCanvases();
            drawMeme();
        };
        img.src = url;
    }

    function drawMeme() {
        // ... (function logic here) ...
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Background
        if (state.currentTemplate) {
            ctx.drawImage(state.currentTemplate, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#1f2937'; // Default dark background
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '24px AppGlobalFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Upload or Select a Template', canvas.width / 2, canvas.height / 2);
        }

        // 2. Draw Layers
        state.layers.forEach((layer, index) => {
            ctx.save();

            // Translate to layer center and apply transformations
            ctx.translate(layer.x, layer.y);
            ctx.rotate(layer.rotation * Math.PI / 180);

            let scaleX = layer.flipX ? -1 : 1;
            let scaleY = layer.flipY ? -1 : 1;
            ctx.scale(scaleX, scaleY);

            if (layer.type === 'text') {
                const font = fonts.find(f => f.id === layer.fontId) || fonts[0];
                const family = `'${font.family}', ${font.fallback}`;
                const weight = layer.isBold ? '900' : 'normal';
                const style = layer.isItalic ? 'italic' : 'normal';

                ctx.font = `${style} ${weight} ${layer.fontSize}px ${family}`;
                ctx.fillStyle = layer.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw outline
                ctx.strokeStyle = 'black';
                ctx.lineWidth = Math.max(2, layer.fontSize / 30);

                const lines = layer.content.split('\n');
                let lineHeight = layer.fontSize * 1.1; // Add padding for line height
                let totalHeight = lines.length * lineHeight;
                let startY = -(totalHeight / 2) + (lineHeight / 2);

                lines.forEach((line, lineIndex) => {
                    let lineY = startY + lineIndex * lineHeight;
                    ctx.strokeText(line, 0, lineY);
                    ctx.fillText(line, 0, lineY);
                });

                // Bounding box calculation (approximate, needed for hit testing)
                const textMetrics = ctx.measureText(layer.content.split('\n')[0]);
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                const textHeight = totalHeight;

                layer.bbox = {
                    w: textWidth,
                    h: textHeight,
                    x: -textWidth / 2,
                    y: -(textHeight / 2)
                };

            } else if (layer.type === 'image' && layer.imageObject) {
                const img = layer.imageObject;
                const scaledW = img.width * layer.scale;
                const scaledH = img.height * layer.scale;
                const halfW = scaledW / 2;
                const halfH = scaledH / 2;

                ctx.drawImage(img, -halfW, -halfH, scaledW, scaledH);

                layer.bbox = {
                    w: scaledW,
                    h: scaledH,
                    x: -halfW,
                    y: -halfH
                };
            }

            // Draw selection box if selected
            if (index === state.selectedLayerIndex) {
                ctx.strokeStyle = state.drawingMode ? 'transparent' : 'red';
                ctx.lineWidth = 3 / (canvas.width / 600); // Scale linewidth based on canvas size
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(layer.bbox.x, layer.bbox.y, layer.bbox.w, layer.bbox.h);
                ctx.setLineDash([]);
            }

            ctx.restore();
        });
    }

    // --- All other functions (updateDrawingColor, setupDrawingInteractions, etc.) need to be here to make the app work. ---

    // (Due to space constraints, I'm omitting the remaining helper functions that handle
    // canvas interaction, drawing, and control updates, but they must be included
    // in your final file for the app to function as a layer editor.)

    // Placeholder for remaining essential functions to prevent errors
    function updateDrawingColor(color) { state.drawingColor = color; updateDrawingContext(); }
    function updateDrawingSize(size) { state.drawingSize = parseInt(size); updateDrawingContext(); }
    function updateDrawingBrush(brush) { state.drawingBrush = brush; updateDrawingContext(); }
    function clearDrawingLayer() { drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); }
    function updateCurrentTextContent() { /* ... */ }
    function toggleStyle(style) { /* ... */ }
    function updateTextColor() { /* ... */ }
    function updateFontSize() { /* ... */ }
    function updateItemScale() { /* ... */ }
    function downloadMeme() { /* ... */ }
    function setupCanvasInteractions() { /* ... */ }
    function setupDrawingInteractions() { /* ... */ }
    // ... all other original functions

    // NOTE: Ensure you include all the detailed functions from your original project
    // that handle layer manipulation, drawing, mouse/touch events, and control updates!

</script>
</body>
</html>